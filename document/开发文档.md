# DSLBot开发文档



本项目共分为词法分析、语法分析、解释器、后端应答、前端GUI，共5个模块。前四个模块在后端实现，最后一个模块在前端实现。他们之间的运作关系如下所示：

```mermaid
graph LR;
file((.bot文件)) --> 词法分析 --> symbol_list("符号表:<br>TokenType1, atrribute1;<br>TokenType1, atrribute1;<br>...") --> 语法分析 --> grammar("语法树:<br>'__GLOBAL__': <br>identifier1: value1,<br>identifier2: value2, <br>...<br>status1: {<br>Operate	..., <br>Speak	..., <br>Hear	..., <br>Wait	..., <br>Timeout	..., <br>Default	...<br>}<br>...") --> 解释器 -- 构造应答 --> back["后端应答:<br>user_list存储每一个用户<br>当前的状态和变量值"] -- 提供应答 -->前端GUI
前端GUI -- 提供输入 -->back
back -- 移交输入 --> 解释器
back -- 状态转移, 更新变量 -->back
```

## 词法分析模块

### 数据结构

| 变量名           | 变量类型           | 描述                                                         |
| ---------------- | ------------------ | ------------------------------------------------------------ |
| `token_type_str` | `list`             | 其中存储着所有记号的类型字符串，方便在调试测试时进行打印输出 |
| `keyword_str`    | `list`             | 其中存储着所有的关键字字符串，用于在进行词法分析时匹配关键字 |
| `LexError`       | `class(Exception)` | 用于报出词法分析阶段的错误                                   |
| `TokenType`      | `class(IntEnum)`   | 用于描述记号类型的枚举类                                     |

### API

#### 类：Token

> 一个记号是一个形如<属性，属性值>的二元组。Token类是一个用于描述记号的二元组。

##### 实例属性

- `Token._type: TokenType`

  用于描述一个记号的属性

- `Token._attr: str`

  用于描述一个记号的属性值

##### 实例方法

- `Token.__init__(self, type: TokenType = TokenType.Error, attr: str = "") -> None`

  `Token`类的构造函数。

- `Token.__str__(self) -> str`

  `Token`类转换成字符串类型的类型转换函数。为了在调试和测试的时候方便输出，通过这个函数，可以直接使用`str(Token)`来打印一个记号的属性和属性值。

#### 类：Lexer

> 词法分析器，从文件输入字符流，分析这些字符，并生成一个记号流

##### 实例属性

- `Lexer.token_list: list[Token]`

  用于保存输出的记号流。

- `Lexer.input: IO`。

  输入文件的输入流。

##### 实例方法

- `Lexer.__init__(self, filePath: str) -> None`

  `Lexer`类的构造函数，会将`filePath`路径下的文件打开作为输入文件的输入流。

- `Lexer.lex() -> list[Token]`

  词法分析函数，根据每个由空格分割开的单词的模式决定他们是什么类型的记号，记录他们的属性和属性值并保存到`Lexer.token_list`中，最后进行返回。

  可能会抛出的异常有：

  - LexError: Unclosed string constant ——未闭合的字符串
  - LexError: Unclosed identifier —— 未闭合的标识符

- `Lexer.show_list() -> None`

  打印输出保存好的记号流，调试测试时使用。

## 语法分析模块

### 数据结构

| 变量名       | 变量类型           | 描述                       |
| ------------ | ------------------ | -------------------------- |
| `ParseError` | `class(Exception)` | 用于报出词法分析阶段的错误 |
| `WaitType`   | `class(IntEnum)`   | 用于描述等待的类型         |

### API

#### 类：Parser

##### 实例属性

- `Parser.current_status: str`

  当前正在处理的状态名，初始为`""`。

- `Parser.idx: Int`

  这是一个在输入的记号流中的索引，代表当前处理到的位置。

- `Parser._token_list: list[Token]`

  输入的记号流。


- `Parser.has_main: bool`

  当前已解析的状态中是否含有`main`状态。

- `Parser.tree: dict`

  生成的语法树，具体结构如下：

  ```json
  {
    "__GLOBAL__": {
      "%id1%": value1,
      "%id2%": value2,
      ...
    },
    status1_name: {
      "Speak": "Speak something",
      "Wait": 5,
      "Hear": {
        "regex1": hear1_status,
        "regex2": hear2_status,
        ...
      },
      "Default": default_status,
      "Timeout": timeout_status,
      "Operate": {
        "%id1%": value1,
      	"%id2%": value2,
      	...
      }
    }
  }
  ```


##### 实例方法

- `Parser.__init__(self, token_list: list[Token]) -> None`

  `Parser`类的构造函数，请注意其中对于`Parser.tree`的初始化。

  ```python
  def __init__(self, token_list: list[Token]) -> None:
          self.current_status = ""
          self.idx = 0
          self._token_list = token_list
          self.tree = {
              "__GLOBAL__":{},
              "main":{
                  "Speak": "",
                  "Wait": None,
                  "Hear": {},
                  "Default": "",
                  "Timeout": "",
                  "Operate":{}
              }
          }
  ```

  在初始化`Parser.tree`时，会先添加一个空的字典用于存储所有的变量；然后自动把main状态添加进来，尽管此时还没有确定用户是否真的编写了`main`状态，但是这有利于稍后处理全局变量。在解析完所有的状态之后会进行一次检查，如果用户真的没有定义`main`状态，则会在语法分析的结束阶段抛出异常。

- `Parser.parse(self) -> dict`

  这个函数会不断的根据目前读到的关键字或者标识符选择相应的语法分析方案进行分析。在每次解析完成一个状态后，都会进行一次检查，检查这个刚刚完成解析的状态里的语句是否合法。在所有符号都解析完毕之后，会最后检查一下用户有没有编写`main`状态，然后返回生成的语法树。

  可能会抛出的异常有：

  - ParseError: Expected a keyword or an identifier —— 当语法分析器期望一个关键字或者标识符的时候却接收到了其他输入。
  - ParseError: No main status to begin with —— 没有起始状态`main`

- `Parser.parse_status(self) -> None`

  这个函数是语法分析器读取到关键字Status时采取的行为。它会首先检查上一个状态是否合法，然后开始在语法树中为接下来要创建的新状态建立新的字典。

  可能会抛出的异常有：

  - ParseError: Expected a Status name —— Status关键字之后紧跟着的不是一个状态名
  - ParseError: Duplicate Status name:  %self._token_list[self.idx]._attr% —— 重复的状态名

- `Parser.parse_speak(self)`

  这个函数是语法分析器读取到关键字Speak时采取的行为。它会把该条Speak语句的内容插入到当前状态的语法树中。

  可能会抛出的异常有：

  - ParseError: Expected a string constant —— Speak关键字之后紧跟着的不是一个字符串常量

- `Parser.parse_hear(self)`

  这个函数是语法分析器读取到关键字Hear时采取的行为。它会把该条Hear语句中对应的正则表达式和转移状态插入到当前状态的语法树中。

  可能会抛出的异常有：

  - ParseError: Expected a string constant —— Hear关键字之后紧跟着的不是一个字符串常量（正则表达式）
  - ParseError: Expected a status to transfer —— 正则表达式之后紧跟着的不是一个状态名

- `Parser.parse_wait(self)`

  这个函数是语法分析器读取到关键字Wait时采取的行为。它会把该条Wait语句中对应的等待时间和转移状态插入到当前状态的语法树中。

  可能会抛出的异常有：

  - ParseError: Expected a wait time —— Wait关键字之后紧跟着的不是一个数字常量
  - ParseError: Wait time can only be an integer greater than 0. —— 等待时间不是一个正整数

- `Parser.parse_default(self)`

  这个函数是语法分析器读取到关键字Default时采取的行为。它会把该条Default语句中对应的转移状态插入到当前状态的语法树中。

  可能会抛出的异常有：

  - ParseError:  Expected a Status name —— Default关键字之后紧跟着的不是一个状态名

- `Parser.parse_timeout(self)`

  这个函数是语法分析器读取到关键字Timeout时采取的行为。它会把该条Timeout语句中对应的转移状态插入到当前状态的语法树中。

  可能会抛出的异常有：

  - ParseError:  Expected a Status name —— Timeout关键字之后紧跟着的不是一个状态名

- `Parser.parse_variable(self)`

  这个函数是语法分析器读取到一个标识符采取的行为。它会把该标识符的赋值语句插入到当前状态的语法树中，并把这个标识符添加到语法树中的\_\_GLOBAL\_\_表中。注意：如果仅仅出现了一个标识符，而没有出现相应的赋值语句，会将该标识符的初值置为`None`。

  可能会抛出的异常有：

  - ParseError:  Expected a number or string constant —— 赋值语句的右值不是一个数字或字符串常量

- `Parser.status_check(self) -> None`

  该函数在每次解析完一个状态，开始解析下一个状态之前，对刚刚解析的状态进行一次检查。并且记录`main`状态是否出现。

  可能会产生的警告有：

  - UserWarning: Status  %self.current_status% has to wait forever before goto the timeout status. —— 当一个状态中只有Timeout语句，却没有Wait语句
  - UserWarning: Status %self.current_status % has nothing to speak. —— 当一状态中没有Speak语句

  可能会抛出的异常有：

  - ParseError: Status %self.current_status% has a valid wait time but no Timeout status set. —— 当一个状态中只有Wait语句，却没有Timeout语句

## 解释器模块

## 后端应答模块

## 前端GUI模块

前端GUI是由一个React组件实现的，它的核心在`client/DSLbot.jsx`。在该文件中定义了一个React组件叫做DSLBot，这个组件在平常只是以一个客服标志普通的悬浮在页面上，如下图所示：





当用户单击这个按钮之后，便会打开一个与机器人的聊天窗口，如下图所示：

![image-20221111025348907](https://tva1.sinaimg.cn/large/008vxvgGly1h80m5l2kfyj31gp0u0t9f.jpg)

用户便可以通过这个窗口与客服机器人进行对话。

下面详细阐述该组件的实现方式。

### 渲染函数

在渲染函数中返回的jsx对象的大体结构如下所示，先将渲染函数呈现出来有助于了解前端的整体架构。

```jsx
<Button onclick={() => this.handleClick()}>
  {/*该部分是页面上的悬浮按钮*/}
</Button>
<Modal
  {/*该部分是对话框*/}
  open={this.state.modalOpen}
  onCancel = {() => this.setState({modalOpen: false})}
  footer={
    {/*对话框的脚部是一个输入框*/}
      <Input 
           onPressEnter={() => this.handleEnter()}
           onChange={this.keyUp}
           value={this.state.inputValue}
           ></Input>
    }>
  {/*对话框的内容是一个列表*/}
  <List>
    {/*实时呈现this.state.msgList中的内容，通过this.handleResponse()函数更新*/}
  </List>
</Modal>
```

### state变量表

下面介绍需要实时渲染的state变量：

| 变量名      | 数据类型                                 | 功能                                                         |
| ----------- | ---------------------------------------- | ------------------------------------------------------------ |
| `modalOpen` | boolean                                  | 用于记录当前对话框是否处于打开状态。                         |
| msgList     | list[{isUser: boolean, content: string}] | 用于记录对话框中的消息，isUser用于标注该消息是否为用户所发送的消息，content为消息内容。 |
| inputValue  | string                                   | 用于实时记录输入框中的内容                                   |
| token       | string                                   | 当前用户与后端通信的凭证                                     |
| timerID     | int                                      | 当前超时计时器的编号                                         |

### Button与handleClick()

在用户点击完页面上悬浮的按钮后，程序需要完成两个任务：

1. 将对话框呈现出来；
2. 建立与后端的链接。

其中第一个任务只需要将`modalOpen`的值设置为true即可；第二个任务需要用axios库与后端进行一次通信，请求到一个token和要显示在对话框中的第一条信息，如下所示：

```jsx
handleClick = () => {
        if (!this.state.token) {
            axios.get("http://127.0.0.1:8000/token").then(result => {
                this.setState({
                    token: result.data.token,
                    msgList: [
                        ...this.state.msgList,
                    {isUser: false, content: result.data.message}
                    ],
                })
            })
        }
```

